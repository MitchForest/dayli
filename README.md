# dayli

**Stop managing your work. Start doing it.**

## The Truth Nobody Talks About

You don't have a productivity problem. You have a decision fatigue problem.

Every morning, you open your laptop to 15 tabs, 200 emails, and 30 tasks. You spend the first hour "planning your day" - which is really just anxiety-driven task shuffling. By the time you actually start working, your best mental energy is gone.

**The real tragedy?** You know exactly what important work needs doing. But it's buried under a mountain of maybe-important, might-be-urgent, should-probably-check noise.

## What dayli Actually Does

dayli is an AI executive assistant that makes every decision about what you should work on, so you don't have to.

Open dayli and see your day already planned:
- Your 3-7 most important tasks scheduled in time blocks
- Emails analyzed by importance AND urgency
- Focus time protected in your calendar
- Everything orchestrated by AI that learns your patterns

No task lists. No priorities. No badges. Just a clean schedule and a chat interface.

## Who Is This For?

dayli is for knowledge workers who:
- Know the 80/20 principle but struggle to apply it daily
- Want to process emails and meetings efficiently to create time for deep work
- Are tired of productivity theater and want real focus
- Need things to not fall through the cracks
- Value their time and attention above all else

## Real User Stories (How We Actually Help)

### Story 1: "The Morning Paralysis"
**Alex, 28, Senior Software Engineer**

*The Pain:* "I'd open my laptop at 9am and see 47 unread emails, 3 Slack channels on fire, and my task list from yesterday. I'd spend 45 minutes 'organizing' - really just moving anxiety around. By the time I started coding, it was almost 10am and I was already mentally exhausted."

*How dayli Solves It:*
```
Alex at 9am: "Plan my day"

dayli: "I've analyzed your 47 emails. 3 need responses this morning (scheduled 11-11:30am), 
12 are FYIs (archived), and the rest can wait. Your critical API refactor has a 2-hour 
deep work block starting now. Your calendar is blocked, Slack is paused. Just start coding."

Result: Alex starts actual work at 9:02am with zero decisions made.
```

**The Feature Magic:**
- **Adaptive Scheduling**: AI already made all the decisions
- **Email Triage**: 47 emails → 3 actions
- **Protected Focus**: Calendar auto-blocked, no interruptions

### Story 2: "The Context Switching Nightmare"
**Sarah, 34, Product Manager**

*The Pain:* "Every 15 minutes something 'urgent' would pop up. A Slack from engineering, a customer email, a meeting invite. I'd handle each one immediately because I didn't want to drop balls. By 5pm, I'd realize I never worked on the strategy doc that actually mattered."

*How dayli Solves It:*
```
10:30am interrupt: "Sarah, the CEO wants to meet about pricing at 2pm"

dayli: "I see the meeting request. You're currently in deep work on the Q4 strategy 
(1 hour left). I'll accept the meeting but I'm moving your email block to 3:30pm 
and pushing non-urgent items to tomorrow. Keep focusing - I've handled it."

Sarah stays in flow. dayli handles the Tetris.
```

**The Feature Magic:**
- **Intelligent Interruption Handling**: AI decides what's truly urgent
- **Automatic Rescheduling**: Adjusts the day without breaking focus
- **Context Preservation**: Protects current deep work above all

### Story 3: "The Invisible Workload"
**Jordan, 31, Marketing Director**

*The Pain:* "My calendar showed 4 hours of meetings, but I had 6 hours of work. Email responses, campaign reviews, team feedback - all invisible labor that happened in the cracks. I'd work until 8pm daily because I couldn't see the real workload."

*How dayli Solves It:*
```
Jordan: "I feel like I'm drowning but my calendar looks fine"

dayli: "You have 73 unscheduled tasks from emails and Slack. Based on your patterns:
- Campaign review: 45 min (scheduling at 9am)
- 12 quick email replies: 30 min batch (2pm)  
- Team feedback docs: 1 hour (4pm)

I've made all your invisible work visible and scheduled. Your day ends at 5:30pm."
```

**The Feature Magic:**
- **Task Extraction**: Pulls tasks from emails/messages automatically
- **Time Estimation**: Learns how long things actually take you
- **Visible Scheduling**: Nothing happens outside of time blocks

### Story 4: "The Energy Mismatch"
**Maya, 29, Data Scientist**

*The Pain:* "I'd schedule deep analysis for 3pm when my brain was mush, then waste my sharp morning energy on email. I knew my patterns but kept fighting them. By Friday, I'd have accomplished half of what I intended."

*How dayli Solves It:*
```
Maya: "Schedule my model training work"

dayli: "I notice you complete complex work 3x faster before noon. I've scheduled:
- 9-11am: Model training (your peak focus time)
- 11-11:30am: Email batch (lower energy needed)
- 2-3pm: Data cleaning (repetitive, good for afternoon)

This matches your actual energy patterns from the last 30 days."
```

**The Feature Magic:**
- **RAG Learning System**: Tracks when you're actually productive
- **Energy-Aware Scheduling**: Matches work type to energy level
- **Pattern Recognition**: Learns without surveys or manual input

## The dayli Difference

1. **We hide more than we show** - Yesterday's tasks? Gone. Next week? Doesn't exist.
2. **AI has authority** - It decides, you execute (or override when needed)
3. **Constraints drive productivity** - 3-7 tasks isn't a limitation, it's a feature
4. **Natural language is the only interface** - If you need a button, we've failed
5. **Learning without dashboards** - The AI gets smarter, you stay focused

## The Actual UI: Radical Simplicity

```
┌─────────────────────────────────┬──────────────────────┐
│  📅 Today's Schedule            │  💬 AI Assistant     │
│                                 │                      │
│  9:00 ┌─────────────────┐      │  "Plan my day"       │
│       │ Deep Work Block │      │                      │
│       │ Payment Refactor│      │  "I'll analyze your  │
│       │ ✓ Task 1       │      │  calendar and emails,│
│       │ ○ Task 2       │      │  then create an      │
│       └─────────────────┘      │  optimal schedule."  │
│                                 │                      │
│ 11:00 ┌─────────────────┐      │  [AI is thinking...] │
│       │ Email Block     │      │                      │
│       │ 12 to process   │      │  "Done! I've         │
│       └─────────────────┘      │  scheduled 3 focus   │
│                                 │  blocks and batched  │
│ 12:00 ┌─────────────────┐      │  your emails for     │
│       │ Lunch Break     │      │  11am."              │
│       │ Protected       │      │                      │
│       └─────────────────┘      │                      │
└─────────────────────────────────┴──────────────────────┘
```

Two panels. That's it. Schedule on the left, AI chat on the right.

## Core Features (What We Actually Built)

### 🧠 AI-Powered Natural Language Control
Everything happens through chat. No buttons, no menus.
- **"Plan my day"** → AI analyzes everything and creates optimal schedule
- **"Move my meeting to 3pm"** → Done, calendar updated
- **"Process my emails"** → Triaged by importance/urgency, scheduled
- **"What should I work on?"** → Context-aware suggestion based on time/energy

### 📅 Adaptive Scheduling Workflow
Powered by LangGraph, the scheduling system adapts to your current state:
- **Empty schedule?** Full daily planning with optimal distribution
- **Partially filled?** Intelligent gap-filling  
- **Overbooked?** Smart optimization and task deferral
- **Always protected:** Lunch breaks at your preferred time

### 📧 Two-Dimensional Email Triage
Our email workflow analyzes on two axes:

|                | **Urgent** | **Can Wait** | **No Response** |
|----------------|------------|--------------|-----------------|
| **Important**  | Today block | Tomorrow | Archive |
| **Not Important** | Quick batch | Defer | Archive |
| **Archive** | - | - | Auto-archive |

Result: 80% of emails handled without you seeing them.

### 🧠 Multi-Layer RAG Learning System
Every decision is stored and learned from:
- **Pattern Layer**: Long-term behaviors ("always takes lunch at 11:30")
- **Recent Layer**: Last 7 days of decisions
- **Similar Layer**: Past situations with similar context

The AI gets smarter without showing complexity.

### 🔒 Protected Focus Time
When you're in a focus block:
- Google Calendar shows "Deep Work - Busy"
- Meeting invites during this time auto-declined
- Only true emergencies surface

## The Technical Architecture (How We Built This)

### AI Implementation: A Multi-Layer Intelligence System

Our AI architecture combines three powerful technologies to create an intelligent assistant that learns and adapts:

```
┌─────────────────────────────────────────────────────────┐
│                 Vercel AI SDK Layer                     │
│  • Chat interface & streaming responses                 │
│  • Tool orchestration (maxSteps: 5)                     │
│  • Multi-step operations with progress                  │
│  • Natural language understanding                       │
│  • Automatic tool discovery via Registry                │
└──────────────────────┬──────────────────────────────────┘
                       │ Calls tools & workflows
                       ▼
┌─────────────────────────────────────────────────────────┐
│              LangGraph Workflow Layer                   │
│                                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │  Adaptive   │ │   Email     │ │    Task     │      │
│  │ Scheduling  │ │   Triage    │ │Prioritization│     │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
│                                                         │
│  ┌─────────────┐ ┌─────────────┐                       │
│  │  Calendar   │ │   Daily     │                       │
│  │ Management  │ │   Review    │                       │
│  └─────────────┘ └─────────────┘                       │
│                                                         │
│  • Complex state management via channels                │
│  • Multi-node decision trees with conditional edges     │
│  • Context-aware strategy selection                     │
│  • Workflow persistence & resumability                  │
└──────────────────────┬──────────────────────────────────┘
                       │ Enhanced by RAG
                       ▼
┌─────────────────────────────────────────────────────────┐
│          RAG (Retrieval-Augmented Generation)          │
│                                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │
│  │   Pattern   │ │   Recent    │ │   Similar   │      │
│  │    Layer    │ │   Decisions │ │ Situations  │      │
│  └─────────────┘ └─────────────┘ └─────────────┘      │
│                                                         │
│  • Vector embeddings via OpenAI                         │
│  • pgvector for similarity search                       │
│  • Learns from every decision & rejection               │
│  • Context injection into workflows                     │
└─────────────────────────────────────────────────────────┘
```

### How Each Layer Works

#### 1. Vercel AI SDK - The Conversation Layer
The AI SDK manages the chat interface and tool orchestration:

```typescript
// In our chat route
const result = await streamText({
  model: openai('gpt-4-turbo'),
  messages,
  tools: toolRegistry.getAll(), // Auto-discovered tools
  maxSteps: 5, // Multi-step execution
  onStepFinish: async ({ toolCalls, toolResults }) => {
    // Stream progress updates to UI
  }
});
```

**Key Features:**
- **Streaming Responses**: Real-time feedback as AI thinks
- **Tool Chaining**: Can call multiple tools in sequence
- **Progress Tracking**: Users see what's happening
- **Error Recovery**: Graceful handling of failures

#### 2. LangGraph - The Workflow Brain
LangGraph handles complex, multi-step workflows with state management:

```typescript
// Example: Adaptive Scheduling Workflow
const workflow = new StateGraph<SchedulingState>({
  channels: {
    userId: null,
    currentSchedule: null,
    unassignedTasks: null,
    strategy: null, // 'full' | 'partial' | 'optimize' | 'task_only'
    proposedChanges: [],
    messages: []
  }
});

// Nodes represent discrete steps
workflow.addNode("fetchData", fetchDataNode);
workflow.addNode("analyzeState", analyzeStateNode);
workflow.addNode("determineStrategy", determineStrategyNode);
workflow.addNode("executeStrategy", executeStrategyNode);

// Conditional routing based on state
workflow.addConditionalEdges(
  "determineStrategy",
  (state) => state.strategy,
  {
    full: "fullPlanningNode",
    partial: "partialFillNode",
    optimize: "optimizationNode",
    task_only: "taskAssignmentNode"
  }
);
```

**Workflow Patterns:**
- **State Channels**: Type-safe state management across nodes
- **Conditional Edges**: Dynamic routing based on analysis
- **Error Boundaries**: Each node can fail gracefully
- **Persistence**: Workflows can be interrupted and resumed

#### 3. RAG System - The Memory Layer
Our RAG implementation gives the AI long-term memory and learning:

```typescript
// Storing context with embeddings
await ragService.storeContext({
  userId: user.id,
  type: 'pattern', // or 'decision', 'preference', 'rejection'
  content: 'User moved lunch from 12:00 to 11:30',
  metadata: { 
    reason: 'Earlier meeting',
    confidence: 0.85 
  },
  embedding: await openai.embeddings.create({
    model: "text-embedding-3-small",
    input: content
  })
});

// Retrieving relevant context
const context = await ragService.getContext(userId, query, {
  includePatterns: true,    // Long-term behaviors
  includeRecent: true,      // Last 7 days
  includeSimilar: true      // Vector similarity search
});

// Context enhances workflow decisions
const enhancedState = {
  ...workflowState,
  ragContext: {
    patterns: ["User prefers lunch at 11:30"],
    recentDecisions: ["Moved meeting yesterday for focus time"],
    similarSituations: ["Last time with back-to-back meetings..."]
  }
};
```

**Learning Mechanisms:**
- **Pattern Extraction**: Identifies recurring behaviors
- **Rejection Learning**: Remembers what NOT to do
- **Preference Evolution**: Tracks changing preferences
- **Similarity Search**: Finds relevant past situations

### The Tool System

Tools are the atomic units of functionality that both the AI SDK and workflows can use:

```typescript
// Tool Registry Pattern - Auto-discovery
export const toolRegistry = new ToolRegistry();

// Tools organized by category
/modules/ai/tools/
  ├── schedule/
  │   ├── createTimeBlock.ts
  │   ├── moveTimeBlock.ts
  │   └── index.ts (exports all)
  ├── email/
  │   ├── readEmailContent.ts
  │   └── processEmailToTask.ts
  └── registry.ts

// Standardized Tool Result format
export const createTimeBlock = tool({
  description: "Create a new time block in the schedule",
  parameters: z.object({
    type: z.enum(['focus', 'email', 'meeting', 'break']),
    title: z.string(),
    startTime: z.string(),
    duration: z.number()
  }),
  execute: async (params) => {
    try {
      const block = await scheduleService.create(params);
      return toolSuccess(block, {
        type: 'schedule',
        content: block
      }, {
        suggestions: ['Add tasks to this block', 'View schedule']
      });
    } catch (error) {
      return toolError('BLOCK_CREATE_FAILED', error.message);
    }
  }
});
```

**Tool Patterns:**
- **Standardized Results**: All tools return `ToolResult<T>`
- **Display Hints**: Tools suggest how to show results
- **Error Handling**: Consistent error format
- **Auto-Registration**: No manual imports needed

### How It All Connects

1. **User Input** → "Plan my day with focus on deep work"

2. **AI SDK Layer**:
   - Understands intent
   - Selects `scheduleDay` tool
   - Begins streaming response

3. **Tool Execution**:
   - `scheduleDay` creates LangGraph workflow
   - Workflow enhanced with RAG context

4. **LangGraph Workflow**:
   - **fetchData**: Gets current state
   - **analyzeState**: Determines schedule fullness
   - **RAG Enhancement**: "User prefers morning deep work"
   - **determineStrategy**: Selects 'partial' strategy
   - **executeStrategy**: Creates optimal blocks
   - **validateSchedule**: Ensures no conflicts

5. **Learning**:
   - Stores decisions in RAG
   - Updates patterns if recurring
   - Learns from any rejections

6. **Response**:
   - Streams natural language summary
   - Shows proposed changes
   - Awaits confirmation

### Why This Architecture?

**1. Separation of Concerns:**
- AI SDK: Conversation and tool orchestration
- LangGraph: Complex stateful logic
- RAG: Memory and learning
- Tools: Atomic operations

**2. Scalability:**
- New tools auto-discovered
- Workflows independent and composable
- RAG learns without code changes

**3. Reliability:**
- Each layer can fail independently
- Workflows are resumable
- State is always consistent

**4. User Experience:**
- Streaming for immediate feedback
- Natural language throughout
- Learning improves over time
- No configuration needed

### The Tools (What AI Can Do)

```typescript
// Direct action tools (AI SDK)
const tools = {
  createTimeBlock,      // "Schedule deep work at 9am"
  moveTimeBlock,        // "Move my meeting to 3pm"
  deleteTimeBlock,      // "Cancel email time"
  assignTaskToBlock,    // "Add code review to morning"
  completeTask,         // "Mark refactor as done"
  getSchedule,          // "What's my schedule?"
  
  // Complex workflows (LangGraph)
  scheduleDay,          // "Plan my day" → Full workflow
  triageEmails,         // "Process emails" → 2D analysis
  prioritizeTasks,      // "What should I work on?" → Smart task selection
  optimizeSchedule,     // "Optimize my day" → Non-destructive improvements
  dailyReview,          // "How did I do?" → Learn and prepare tomorrow
  updatePreference,     // "I prefer lunch at 11:30"
}
```

### Data Flow

```
User Input → AI SDK → Tool Selection → Execute
                ↓                         ↓
            Streaming              Simple Tool or
            Response              LangGraph Workflow
                                         ↓
                                   Complex Logic
                                   (nodes, edges)
                                         ↓
                                   Database/APIs
```

### The Stack

- **Frontend**: Next.js 14 + TypeScript + Tailwind CSS
- **Desktop**: Tauri (10MB native app)
- **AI Orchestration**: 
  - Vercel AI SDK (chat, streaming, tools)
  - LangGraph (complex workflows)
- **LLM**: OpenAI GPT-4 Turbo
- **Vector DB**: Supabase + pgvector (for RAG)
- **Database**: PostgreSQL with RLS
- **Auth**: Supabase Auth (Google OAuth)
- **APIs**: Gmail API, Google Calendar API
- **Monorepo**: Turborepo for coordinated development

## Design Decisions That Matter

### No Manual Controls
- **No settings page** → AI learns your preferences
- **No task creation** → Tasks come from email/calendar/chat
- **No priority levels** → AI decides based on context
- **No drag-and-drop** → Natural language only

### Time as Primary Dimension
```typescript
interface TimeBlock {
  startTime: Date;
  endTime: Date;
  type: 'focus' | 'email' | 'meeting' | 'break';
  tasks: Task[];  // What to do in this block
}
```
Everything has a "when", not just a "what".

### Enforced Constraints
- **3-7 tasks max** per day (hard limit in code)
- **Today-only view** (no week/month views)
- **Single task visible** during focus
- **Protected lunch** (always scheduled)

### AI as Invisible Intelligence
The AI should feel like a brilliant assistant, not a chatbot:
- Never mentions tool names or technical details
- Explains actions in human terms
- Learns without showing learning
- Adapts without configuration

### Trust Through Transparency
- AI explains its reasoning when asked
- Changes preview before applying
- Undo is always available
- You can ask "why did you do that?"

## Architecture Decisions Worth Noting

### Service Factory Pattern
We built a data-source agnostic architecture that allows seamless switching between mock and real data:

```typescript
const factory = ServiceFactory.getInstance();
factory.configure({ userId, supabaseClient }, useMockData);

// Same interface whether mock or real
const schedule = await scheduleService.getScheduleForDate(date);
```

This enables rapid development, testing, and demos without external dependencies.

### Tool-Based AI Architecture
Instead of hard-coded actions, everything is a tool the AI can use:

```typescript
const tools = {
  createTimeBlock,    // "Schedule a 2-hour focus block at 9am"
  moveTimeBlock,      // "Move my meeting to 3pm"
  deleteTimeBlock,    // "Cancel my afternoon email time"
  assignTaskToBlock,  // "Add budget review to morning focus"
  scheduleDay,        // "Plan my day" (triggers full workflow)
};
```

### Multi-Layer RAG Context
We don't just store data - we store understanding:

1. **Pattern Layer**: Long-term behaviors ("usually takes lunch at 11:30")
2. **Recent Layer**: Last 7 days of decisions  
3. **Similar Layer**: Past situations with similar context

This allows queries like "What should I work on?" to consider your current state, recent patterns, and similar past situations.

## How the Workflows Actually Work

### Understanding LangGraph Workflows

Each workflow is a state machine with nodes (processing steps) and edges (transitions). Here's how they work in detail:

### 1. Adaptive Scheduling Workflow
The most complex workflow that intelligently plans your day:

```typescript
// State definition - what flows through the workflow
interface SchedulingState {
  userId: string;
  date: string;
  currentSchedule: TimeBlock[];
  unassignedTasks: Task[];
  taskBacklog: Task[];
  userPreferences: UserPreferences;
  ragContext?: RAGContext;
  strategy?: 'full' | 'partial' | 'optimize' | 'task_only';
  proposedChanges: ScheduleChange[];
  inefficiencies?: Inefficiency[];
  messages: BaseMessage[];
}

// Workflow definition
const workflow = new StateGraph<SchedulingState>({
  channels: {
    // Define all state properties
    userId: null,
    currentSchedule: null,
    // ... etc
  }
});

// Node implementation example
async function determineStrategyNode(state: SchedulingState) {
  // Rule-based strategy selection
  if (state.currentSchedule.length === 0) {
    return { strategy: "full" };
  }
  
  if (state.inefficiencies.length > 2) {
    return { strategy: "optimize" };
  }
  
  // Fall back to LLM for complex cases
  const prompt = `Given schedule density ${state.currentSchedule.length} 
    and ${state.unassignedTasks.length} tasks, choose strategy...`;
  
  const strategy = await llm.invoke(prompt);
  return { strategy };
}

// Conditional routing
workflow.addConditionalEdges(
  "determineStrategy",
  (state) => state.strategy,
  {
    full: "fullPlanningNode",
    partial: "partialFillNode",
    optimize: "optimizationNode",
    task_only: "taskAssignmentNode"
  }
);
```

**Key Innovations:**
- **Smart Strategy Selection**: Combines rules + LLM for routing
- **Inefficiency Detection**: Finds gaps, fragmentation, poor timing
- **RAG Enhancement**: Every decision informed by user patterns
- **Atomic Changes**: All modifications as discrete, revertable operations

### 2. Email Triage Workflow
Two-dimensional analysis (importance × urgency) with intelligent batching:

```typescript
interface EmailManagementState {
  emails: Email[];
  backlogEmails: EmailBacklog[];
  analyzedEmails: AnalyzedEmail[];
  emailBatches: EmailBatch[];
  proposedBlocks: ScheduleBlock[];
}

// The 2D analysis node
async function analyzeEmailsNode(state: EmailManagementState) {
  const model = new ChatOpenAI({ temperature: 0 });
  
  // Batch analysis for efficiency
  const prompt = `Analyze these emails on two dimensions:
    Importance: important | not_important | archive
    Urgency: urgent | can_wait | no_response
    
    Consider:
    - Sender relationship (boss, client, newsletter)
    - Subject keywords (urgent, FYI, action required)
    - Content preview
    - Historical patterns from RAG
    
    ${state.emails.map(e => formatEmail(e)).join('\n')}`;
  
  const analysis = await model.invoke(prompt);
  
  // Create action matrix
  return {
    analyzedEmails: emails.map(email => ({
      ...email,
      importance: analysis[email.id].importance,
      urgency: analysis[email.id].urgency,
      suggestedAction: determineAction(importance, urgency),
      estimatedResponseTime: estimateTime(email)
    }))
  };
}

// Smart batching based on type
function batchByStrategyNode(state: EmailManagementState) {
  const batches = {
    important_urgent: [],      // Morning focus
    quick_replies: [],         // 15-min batch
    thoughtful_responses: [],  // Afternoon block
    can_wait: [],             // Tomorrow
    archive: []               // Auto-archive
  };
  
  // Group by action type
  state.analyzedEmails.forEach(email => {
    const key = `${email.importance}_${email.urgency}`;
    batches[actionMatrix[key]].push(email);
  });
  
  // Create time-boxed blocks
  return {
    emailBatches: Object.entries(batches)
      .filter(([_, emails]) => emails.length > 0)
      .map(([type, emails]) => ({
        type,
        emails,
        totalTime: emails.reduce((sum, e) => sum + e.estimatedResponseTime, 0),
        suggestedTimeSlot: getOptimalSlot(type, state.ragContext)
      }))
  };
}
```

### 3. Task Management Workflow
Context-aware task scoring and recommendation:

```typescript
// Sophisticated scoring algorithm
async function scoreTasksNode(state: TaskManagementState) {
  const scoredTasks = state.tasks.map(task => {
    let score = 0;
    
    // Base priority score
    score += priorityScores[task.priority]; // high: 100, medium: 50, low: 25
    
    // Age factor (Parkinson's Law prevention)
    const ageInDays = daysSince(task.created_at);
    score += Math.min(ageInDays * 5, 25); // Max 25 points for age
    
    // Energy matching
    const energyMatch = calculateEnergyMatch(
      task.estimated_minutes,
      task.complexity,
      state.currentEnergy
    );
    score += energyMatch * 20;
    
    // Time of day optimization
    if (isOptimalTimeForTask(task.type, new Date())) {
      score += 15;
    }
    
    // RAG boost - similar successful completions
    const similarSuccess = findSimilarCompletedTasks(
      task,
      state.ragContext.similarSituations
    );
    score += similarSuccess.length * 10;
    
    // Deadline proximity
    if (task.deadline) {
      const urgency = calculateUrgency(task.deadline);
      score += urgency * 30;
    }
    
    return {
      ...task,
      score,
      reasoning: explainScore(score, factors),
      confidence: calculateConfidence(factors)
    };
  });
  
  return { 
    scoredTasks: scoredTasks.sort((a, b) => b.score - a.score)
  };
}
```

### 4. Calendar Management Workflow
Intelligent conflict resolution and meeting optimization:

```typescript
// Conflict detection with severity analysis
async function detectConflictsNode(state: CalendarManagementState) {
  const conflicts = [];
  
  // Sort meetings chronologically
  const sorted = [...state.meetings].sort(byStartTime);
  
  for (let i = 0; i < sorted.length - 1; i++) {
    const current = sorted[i];
    const next = sorted[i + 1];
    
    const overlap = calculateOverlap(current, next);
    
    if (overlap > 0) {
      conflicts.push({
        meeting1: current,
        meeting2: next,
        overlapMinutes: overlap,
        severity: categorizeSeverity(overlap, current, next),
        suggestedResolution: await generateResolution(
          current,
          next,
          state.ragContext
        )
      });
    }
    
    // Also check for back-to-back without breaks
    if (isBackToBack(current, next) && needsBreak(current, next)) {
      conflicts.push({
        type: 'no_break',
        severity: 'medium',
        suggestedResolution: 'Add 15-minute buffer'
      });
    }
  }
  
  return { conflicts };
}

// Smart resolution based on meeting metadata
async function resolveConflictsNode(state: CalendarManagementState) {
  const resolutions = [];
  
  for (const conflict of state.conflicts) {
    // Use meeting importance scores
    const importance1 = scoreMeetingImportance(conflict.meeting1);
    const importance2 = scoreMeetingImportance(conflict.meeting2);
    
    // Check flexibility
    const flexibility1 = await checkFlexibility(conflict.meeting1);
    const flexibility2 = await checkFlexibility(conflict.meeting2);
    
    // Generate resolution
    if (flexibility2 > flexibility1) {
      const newSlot = await findNextAvailableSlot(
        conflict.meeting2,
        state.ragContext.patterns // User's preferred meeting times
      );
      
      resolutions.push({
        action: 'reschedule',
        meeting: conflict.meeting2,
        newTime: newSlot,
        reason: 'Lower priority and more flexible'
      });
    }
  }
  
  return { proposedChanges: resolutions };
}
```

### 5. Daily Review Workflow
Learning and pattern extraction:

```typescript
// Extract patterns from today's activities
async function extractTodayPatternsNode(state: DailyReviewState) {
  const patterns = [];
  
  // 1. Schedule adherence analysis
  const planned = state.todaySchedule.filter(b => b.planned);
  const actual = state.todaySchedule.filter(b => b.actual);
  
  const adherence = calculateAdherence(planned, actual);
  
  if (adherence < 0.7) {
    patterns.push({
      type: 'behavior',
      description: 'Frequent schedule deviations',
      confidence: 0.9,
      actionable: true,
      suggestion: 'Build in more buffer time'
    });
  }
  
  // 2. Productivity patterns
  const productivityByHour = analyzeProductivityByHour(
    state.completedTasks,
    state.todaySchedule
  );
  
  const peakHours = findPeakProductivity(productivityByHour);
  
  patterns.push({
    type: 'productivity',
    description: `Peak productivity: ${peakHours.join(', ')}`,
    confidence: calculateConfidence(productivityByHour),
    actionable: true,
    suggestion: 'Schedule important work during peak hours'
  });
  
  // 3. Task completion patterns
  const completionPatterns = analyzeTaskCompletion(
    state.completedTasks,
    state.incompleteTasks
  );
  
  // 4. Meeting patterns
  const meetingPatterns = analyzeMeetingBehavior(
    state.todaySchedule.filter(b => b.type === 'meeting')
  );
  
  return { patterns };
}

// Update RAG with learnings
async function updateLearningsNode(state: DailyReviewState) {
  const learningService = new LearningPatternsService();
  
  // Store high-confidence patterns
  for (const pattern of state.patterns) {
    if (pattern.confidence > 0.7 && pattern.actionable) {
      await ragService.storeContext({
        userId: state.userId,
        type: 'pattern',
        content: pattern.description,
        metadata: {
          date: state.date,
          patternType: pattern.type,
          confidence: pattern.confidence,
          occurrences: pattern.occurrences || 1
        }
      });
    }
  }
  
  // Store daily summary for similarity search
  const dailySummary = generateDailySummary(state);
  
  await ragService.storeContext({
    userId: state.userId,
    type: 'decision',
    content: dailySummary,
    metadata: {
      date: state.date,
      metrics: extractDailyMetrics(state)
    }
  });
  
  return { learningsStored: true };
}
```

### The RAG Learning System in Detail

```typescript
// How RAG enhances every decision
class ContextEnhancer {
  async enhanceWorkflowState(
    userId: string,
    workflowType: string,
    currentState: any
  ) {
    // Build semantic query
    const query = this.buildContextQuery(workflowType, currentState);
    
    // Multi-layer retrieval
    const context = await ragService.getContext(userId, query, {
      includePatterns: true,    // Long-term behaviors
      includeRecent: true,      // Last 7 days
      includeSimilar: true      // Vector similarity
    });
    
    // Enhance state with relevant context
    return {
      ...currentState,
      ragContext: {
        patterns: this.summarizePatterns(context.patterns),
        recentDecisions: this.summarizeDecisions(context.recentDecisions),
        similarSituations: this.summarizeSituations(context.similarSituations)
      }
    };
  }
}

// Vector similarity search using pgvector
CREATE FUNCTION search_similar_contexts(
  query_embedding vector(1536),
  match_user_id UUID,
  match_count INT DEFAULT 10,
  threshold FLOAT DEFAULT 0.7
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  similarity FLOAT
)
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    id,
    content,
    1 - (embedding <=> query_embedding) AS similarity
  FROM rag_context
  WHERE user_id = match_user_id
    AND 1 - (embedding <=> query_embedding) > threshold
  ORDER BY embedding <=> query_embedding
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql;
```

### Workflow Persistence & Resumability

```typescript
// Every workflow can be interrupted and resumed
export function createPersistentWorkflow<T>(
  workflow: StateGraph<T>,
  type: string
): StateGraph<T> {
  const workflowId = crypto.randomUUID();
  
  // Save state after each node
  workflow.afterNode = async (nodeName: string, state: T) => {
    await persistenceService.saveWorkflowState(workflowId, {
      currentNode: nodeName,
      state: state as any,
      status: nodeName === END ? 'completed' : 'in_progress',
    });
  };
  
  // Handle errors gracefully
  workflow.onError = async (error: Error, nodeName: string, state: T) => {
    await persistenceService.saveWorkflowState(workflowId, {
      status: 'failed',
      error: error.message,
      currentNode: nodeName,
      state: state as any
    });
  };
  
  return workflow;
}

// Resume interrupted workflow
async function resumeWorkflow(workflowId: string) {
  const saved = await persistenceService.getWorkflowState(workflowId);
  if (!saved) throw new Error('Workflow not found');
  
  const workflow = getWorkflowByType(saved.type);
  return workflow.resume(saved.state, saved.currentNode);
}
```

## Current Implementation Status

### ✅ What's Built & Working
- Complete time-block UI with all block types
- AI chat with streaming responses (Vercel AI SDK)
- All CRUD tools for schedule manipulation
- Service factory pattern (mock/real data switching)
- Database schema with pgvector for embeddings
- Multi-step AI operations with progress tracking
- Basic mock data for all scenarios

### 🚧 In Active Development (Epic 3)
- **Sprint 03.01**: ✅ Core AI tools implementation
- **Sprint 03.02**: 🚧 Adaptive scheduling workflow (LangGraph)
- **Sprint 03.03**: 📅 Email triage workflow (LangGraph)
- **Sprint 03.04**: 📅 RAG system implementation
- **Sprint 03.05**: 📅 Gmail & Calendar API integration
- **Sprint 03.06**: 📅 Change preview & polish

### 📋 All LangGraph Workflows (5 Total)
1. **Adaptive Scheduling** - Intelligent daily planning
2. **Email Triage** - 2D importance/urgency analysis
3. **Task Prioritization** - Smart task selection based on context
4. **Schedule Optimization** - Non-destructive improvements
5. **Daily Review** - Learning and tomorrow preparation

### 🔮 Not Yet Implemented
- Slack integration
- Voice commands  
- Mobile app
- Team features

## The Philosophy (Why We Built It This Way)

**Most productivity apps are procrastination apps in disguise.** They give you infinite ways to organize work instead of doing work.

dayli is different:
- **Shows less, not more** → Only today, only what matters
- **Decides for you** → No analysis paralysis
- **Protects your attention** → Deep work is sacred
- **Learns silently** → No dashboards or analytics

Every technical decision enforces this philosophy:
- Single day view? Can't procrastinate on future planning
- No manual task creation? Forces focus on what exists
- AI-only control? Removes the temptation to fiddle

## Getting Started

```bash
# Clone the repository
git clone https://github.com/yourusername/dayli.git

# Install dependencies
cd dayli
bun install

# Set up environment variables
cp .env.example .env.local
# Add required keys:
# - OPENAI_API_KEY
# - NEXT_PUBLIC_SUPABASE_URL
# - NEXT_PUBLIC_SUPABASE_ANON_KEY
# - GOOGLE_CLIENT_ID (for Gmail/Calendar)
# - GOOGLE_CLIENT_SECRET

# Run database migrations
cd migrations
bun run db:migrate

# Start development
bun run dev

# In another terminal, start desktop app
cd apps/desktop
bun tauri dev
```

## Example: A Real Day with dayli

**8:45 AM - Open dayli**
```
You: "Plan my day"

AI: "I'll analyze your calendar and emails to create an optimal schedule...

Done! Here's your day:
- 9:00-11:00: Deep work on payment refactor (2 tasks)
- 11:00-11:30: Process 8 urgent emails
- 11:30-12:30: Lunch (protected)
- 1:00-2:00: Team standup (from calendar)
- 2:00-4:00: Deep work continuation
- 4:00-4:30: Quick email replies (12 emails)

I've auto-declined 2 meeting requests during your focus blocks and archived 47 non-important emails."
```

**10:30 AM - Meeting cancelled**
```
You: "My 1pm got cancelled"

AI: "Perfect! You have a 1-hour gap. Based on your energy patterns, I suggest:
- Code review for Jordan's PR (45 min)
- Already assigned to the block. Want to start now or keep your current focus?"
```

**4:00 PM - End of day check**
```
You: "How did I do today?"

AI: "You completed 5 of 6 planned tasks. The API refactor was moved to tomorrow's morning block. All urgent emails were handled. Your focus time was 4.5 hours - above your average. See you tomorrow!"
```

## Why This Architecture Matters

1. **Service Interfaces**: Switch between mock and real data seamlessly
2. **AI SDK + LangGraph**: Best tool for each job
3. **RAG with pgvector**: Learn without external dependencies
4. **TypeScript Everywhere**: Type safety from DB to UI
5. **Tauri Desktop**: Native performance, 10MB installer

This isn't over-engineering. Each choice directly supports the goal: help users execute, not manage.

---

**Built for people who want to do deep, meaningful work in a world designed to prevent it.**

Built with TypeScript, powered by AI, designed for focus.

Stop managing. Start doing. 